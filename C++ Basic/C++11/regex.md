# regex / regular expression / 正则表达式 / 新增Header<br>
### 1 定义 / 实际运用的情况<br> 
#### 1.1 用于匹配、查找或替换文本中符合特定模式的字符串<br>
### 2 regex内语法<br>
#### 2.1 regex的基本逻辑是，由一个位置的字符可能情况，一情况的重复出现次数组成模式。还可以附带位置匹配<br><br>
### 2.1.1 单个位置的可能情况<br>
#### 2.1.1.1 单纯字符 ```a - 该位置仅匹配 a```<br>
#### 2.1.1.2 列举字符可能 ```[abcd] - 该位置仅匹配 a 或 b 或 c 或 d``` 可以堆叠列举2.1.1的其他所有可能<br> 
#### 2.1.1.3 连字符 ```[a-z] - 该位置仅匹配 a到z 里的任何一个```<br>
#### 2.1.1.4 反 ```[^...] - 该位置不匹配指定字符中的任何一个```<br>
#### 2.1.1.5 转义字符<br>
#### 2.1.1.5.1.1 ```\d - 该位置匹配任意数字```<br>
#### 2.1.1.5.1.2 ```\D - 等价于^\d```<br>
#### 2.1.1.5.2.1 ```\w - 该位置匹配任意字母,数字,下划线```<br>
#### 2.1.1.5.2.2 ```\W - 等价于^\w```<br>
#### 2.1.1.5.3.1 ```\s - 该位置匹配任意空白字符```<br>
#### 2.1.1.5.3.2 ```\S - 等价于^\s```<br>
#### 2.1.1.6 任意字符 ```. - 匹配任意字符```
### 2.1.2 多个位置的可能情况<br>
#### 2.1.2.1 连续的单纯字符 ```abc - 连续的三个位置仅匹配abc```<br>
#### 2.1.2.2 前面情况的重复<br>
#### 2.1.2.2.1 ```{n} 表示前面的单个位置情况 重复 n次 ```<br>
#### 2.1.2.2.2 ```{n,} 表示前面的单个位置情况 重复 x次 n<=x```<br>
#### 2.1.2.2.3 ```{n,m} 表示前面的单个位置情况 重复 x次 n<=x<=m```<br>
#### 2.1.2.2.4 ```* 等价于{0,} 不重复(不出现)，或者重复随意次数```
#### 2.1.2.2.5 ```+ 等价于{1,} 重复非0(至少得出现一次)的随意次数```
#### 2.1.2.2.6 ```? 等价于{0,1} 不出现或者出现```
### 2.1.3 位置匹配<br>
#### 2.1.3.1 ```^：表示字符串的开始```<br>
#### 2.1.3.2 ```$：表示字符串的结尾```<br>
#### 2.1.3.3 ```\b：表示单词边界```<br>
'er\b' 可以匹配 "never" 中的 'er'，不能匹配 "verb" 中的 'er'<br>
#### 2.1.3.4 ```\B：表示非单词边界```<br>
'er\B' 可以匹配 "verb" 中的 'er'，不能匹配 "never" 中的 'er'<br>
<br><br>
#### 2.2 regex的语法标准可分为，寻常字符，转义字符<br>
#### 2.3 值得注意的是，由于regex的模式的导入接收的是字符串，而转义字符需要一个 \\ 组成，但是导入 \\ 进入字符串还需要另一个 \\ 转义原本的 \\ ，所以要想表示 \\d 需要 \\\\d 的字符串形式<br>
### 3 c++ regex 语法<br>
#### 3.1 基本
#### 3.1.1 目标字符串<br>
#### ```string string_name = "abcd";```<br>
#### 3.1.2 模式 (regex object)<br>
#### ```regex pattern_name("...");```<br>
#### 3.1.3 匹配结果 (smatch object)<br>
#### ```smatch match_name;```<br>
#### 3.1.4 替换字符串<br>
#### ```string replacement_string_name = "ccc";```<br>
#### 3.2 模式匹配 return bool<br>
```if(regex_match(string_name, pattern_name))```<br>
``` {```<br>
```		cout << "match" << endl;```<br>
```	}```<br>
``` else```<br>
``` {```<br>
```		cout << "not match" << endl;```<br>
```	}```<br>
#### 3.3 模式搜索 return bool<br>
```	while (regex_search(string_name, match_name, pattern_name))```<br>
``` {```<br>
```		cout << "search in: " << string_name << endl;```<br>
```		cout << "found: " << match_name[0] << endl;```<br>
```		string_name = match_name.suffix().str();```<br>
```	}```<br>
#### 3.4 模式替换 return string<br>
``` string result_after_replace = regex_replace(string_name, pattern_name, replacement_string_name);```<br>
### 4 实用的regex实例<br>
#### 4.1 MAC<br>
#### 4.1.1 MAC示例<br>
```"00:11:22:AA:BB:CC"```<br>
```"00-11-22-AA-BB-CC"```<br>
#### 4.1.2 MAC的pattern<br>
```regex pattern("^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$")```<br>
<br>
#### 4.2 IPv4<br>
#### 4.2.1 IPv4示例<br>
```"255.255.255.289"```<br>
```"1.2.3.4"```<br>
#### 4.2.2 IPv4的pattern<br>
```string_name+='.'```<br>
```regex pattern("((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)\.){4}")```<br>
<br>
#### 4.3 邮箱格式<br>
#### 4.3.1 邮箱格式示例<br>
```"example@example.com"```<br>
#### 4.3.2 邮箱格式的pattern<br>
```regex pattern(R"(\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b)")```R"( )"允许在字符串中使用特殊字符而无需进行额外的转移<br>

<br><p align="right">*最后更新于 2024/7/16 12:22:04*